import math
import pandas as pd
data = {
    'Outlook': ['Sunny','Sunny','Overcast','Rain','Rain','Rain','Overcast','Sunny','Sunny','Rain','Sunny','Overcast','Overcast','Rain'],
    'Temperature': ['Hot','Hot','Hot','Mild','Cool','Cool','Cool','Mild','Cool','Mild','Mild','Mild','Hot','Mild'],
    'Humidity': ['High','High','High','High','Normal','Normal','Normal','High','Normal','Normal','Normal','High','Normal','High'],
    'Wind': ['Weak','Strong','Weak','Weak','Weak','Strong','Strong','Weak','Weak','Weak','Strong','Strong','Weak','Strong'],
    'PlayTennis': ['No','No','Yes','Yes','Yes','No','Yes','No','Yes','Yes','Yes','Yes','Yes','No']
}
df = pd.DataFrame(data)
def entropy(target_col):
    elements, counts = np.unique(target_col, return_counts=True)
    entropy = 0
    for i in range(len(elements)):
        entropy -= (counts[i]/sum(counts)) * math.log2(counts[i]/sum(counts))
    return entropy
def info_gain(data, split_attribute, target_name="PlayTennis"):
    total_entropy = entropy(data[target_name])

    values, counts = np.unique(data[split_attribute], return_counts=True)
    weighted_entropy = 0
    for i in range(len(values)):
        subset = data[data[split_attribute] == values[i]]
        weighted_entropy += (counts[i] / sum(counts)) * entropy(subset[target_name])

    return total_entropy - weighted_entropy
def id3(data, original_data, features, target_attribute="PlayTennis", parent_node_class=None):

    # If all target values are identical → return the value
    if len(np.unique(data[target_attribute])) <= 1:
        return np.unique(data[target_attribute])[0]

    # If dataset is empty → return majority class from original data
    if len(data) == 0:
        return np.unique(original_data[target_attribute])[np.argmax(
            np.unique(original_data[target_attribute], return_counts=True)[1]
        )]
    if len(features) == 0:
        return parent_node_class
    parent_node_class = np.unique(data[target_attribute])[np.argmax(
        np.unique(data[target_attribute], return_counts=True)[1]
    )]
    gains = [info_gain(data, feature, target_attribute) for feature in features]
    best_feature = features[gains.index(max(gains))]
    tree = {best_feature: {}}
    features = [i for i in features if i != best_feature]
    for value in np.unique(data[best_feature]):
        subtree = id3(
            data[data[best_feature] == value],
            original_data,
            features,
            target_attribute,
            parent_node_class
        )
        tree[best_feature][value] = subtree

    return tree
import numpy as np
features = ['Outlook', 'Temperature', 'Humidity', 'Wind']
tree = id3(df, df, features)
print("Decision Tree:\n", tree)



